import * as PIXI from 'pixi.js';
import { axialToPixelOriented, type HexOrientation } from '../../../utils/hexMath'; // NEW: Import orientation-aware functions
import type { HexTile } from '../../../types/mapTypes';
import type { HexTextureSet } from '../../../utils/hexTextureGenerator';

export class HexRenderer {
    private fillSprites = new Map<string, PIXI.Sprite>();
    private borderSprites = new Map<string, PIXI.Sprite>();
    private selectedHexSprite: PIXI.Sprite | null = null;
    private textures: HexTextureSet | null = null;
    private fillContainer: PIXI.Container;
    private borderContainer: PIXI.Container;
    private highlightContainer: PIXI.Container;
    private tileSize: number;
    private hexOrientation: HexOrientation = 'flat-top'; // NEW: Track orientation

    constructor(
        fillContainer: PIXI.Container,
        borderContainer: PIXI.Container,
        highlightContainer: PIXI.Container,
        tileSize: number,
        hexOrientation: HexOrientation = 'flat-top' // NEW: Accept orientation in constructor
    ) {
        this.fillContainer = fillContainer;
        this.borderContainer = borderContainer;
        this.highlightContainer = highlightContainer;
        this.tileSize = tileSize;
        this.hexOrientation = hexOrientation; // NEW: Store orientation
    }

    /**
     * Sets the textures to use for rendering
     */
    setTextures(textures: HexTextureSet): void {
        this.textures = textures;

        // Update all existing sprites to use the new textures
        this.fillSprites.forEach(sprite => {
            sprite.texture = textures.fill;
        });

        this.borderSprites.forEach(sprite => {
            sprite.texture = textures.border;
        });

        // Update highlight sprite if it exists
        if (this.selectedHexSprite) {
            this.selectedHexSprite.texture = textures.highlight;
        }
    }

    /**
     * Updates the hex orientation (NEW)
     */
    setHexOrientation(orientation: HexOrientation): void {
        this.hexOrientation = orientation;
        // Note: textures will be regenerated by the manager, 
        // but coordinate conversion will use the new orientation immediately
    }

    /**
     * Renders visible hexes within the given bounds
     */
    renderVisibleHexes(
        hexTiles: HexTile[],
        visibleBounds: {
            minX: number;
            maxX: number;
            minY: number;
            maxY: number;
        },
        pixelBuffer: number = 0
    ): number {
        if (!this.textures) {
            console.warn('[HexRenderer] No textures available for rendering');
            return 0;
        }

        let drawnCount = 0;
        const visibleHexIds = new Set<string>();

        // Render visible hexes
        hexTiles.forEach((hex) => {
            const pixel = axialToPixelOriented(hex.coordinates.q, hex.coordinates.r, this.tileSize, this.hexOrientation);

            if (
                pixel.x >= visibleBounds.minX - pixelBuffer &&
                pixel.x <= visibleBounds.maxX + pixelBuffer &&
                pixel.y >= visibleBounds.minY - pixelBuffer &&
                pixel.y <= visibleBounds.maxY + pixelBuffer
            ) {
                visibleHexIds.add(hex.id);
                this.renderHex(hex, pixel);
                drawnCount++;
            }
        });

        // Hide non-visible hexes
        this.hideNonVisibleHexes(visibleHexIds);

        return drawnCount;
    }

    /**
     * Renders a single hex at the given pixel position
     */
    private renderHex(hex: HexTile, pixel: { x: number, y: number }): void {
        if (!this.textures) return;

        // Create or update fill sprite
        let fillSprite = this.fillSprites.get(hex.id);
        if (!fillSprite) {
            fillSprite = new PIXI.Sprite(this.textures.fill);
            fillSprite.anchor.set(0.5);
            this.fillContainer.addChild(fillSprite);
            this.fillSprites.set(hex.id, fillSprite);
        }

        // Create or update border sprite
        let borderSprite = this.borderSprites.get(hex.id);
        if (!borderSprite) {
            borderSprite = new PIXI.Sprite(this.textures.border);
            borderSprite.anchor.set(0.5);
            this.borderContainer.addChild(borderSprite);
            this.borderSprites.set(hex.id, borderSprite);
        }

        // Update positions and visibility
        fillSprite.x = pixel.x;
        fillSprite.y = pixel.y;
        fillSprite.visible = true;
        // Alpha will be set below based on biome assignment

        // Update fill color and transparency based on biome or town status
        if (hex.isTown) {
            // Towns get a special black semi-transparent overlay
            fillSprite.tint = 0x000000; // Black
            fillSprite.alpha = 0.8; // 80% opacity
        } else if (hex.biome && hex.biome.color && hex.biome.name !== 'Unassigned' && hex.biome.color !== 'transparent') {
            const colorData = this.parseColor(hex.biome.color);
            fillSprite.tint = colorData.color;
            fillSprite.alpha = colorData.alpha;            // Test alpha behavior for debugging
            this.testAlpha(fillSprite, colorData.alpha, hex.id);
        } else {
            // For unassigned hexes, make them transparent (only border visible)
            fillSprite.tint = 0xFFFFFF;
            fillSprite.alpha = 0; // Transparent for unassigned
        }

        borderSprite.x = pixel.x;
        borderSprite.y = pixel.y;
        borderSprite.visible = true;
        borderSprite.alpha = 1;
    }

    /**
     * Converts a CSS color string to a PIXI color number and alpha value
     */
    private parseColor(colorString: string): { color: number; alpha: number } {
        // Handle common formats: #RRGGBB, rgba(r,g,b,a), rgb(r,g,b)
        if (colorString.startsWith('#')) {
            const result = {
                color: parseInt(colorString.slice(1), 16),
                alpha: 1
            };
            return result;
        }

        if (colorString.startsWith('rgb')) {
            const matches = colorString.match(/[\d.]+/g);

            if (matches && matches.length >= 3) {
                const r = parseInt(matches[0]);
                const g = parseInt(matches[1]);
                const b = parseInt(matches[2]);
                const alpha = matches.length >= 4 ? parseFloat(matches[3]) : 1;

                const result = {
                    color: (r << 16) | (g << 8) | b,
                    alpha: alpha
                };

                return result;
            }
        }

        // Fallback to white if parsing fails
        const fallback = {
            color: 0xFFFFFF,
            alpha: 1
        };
        return fallback;
    }

    /**
     * Hides sprites for hexes that are no longer visible
     */
    private hideNonVisibleHexes(visibleHexIds: Set<string>): void {
        this.fillSprites.forEach((sprite, hexId) => {
            if (!visibleHexIds.has(hexId)) {
                sprite.visible = false;
            }
        });

        this.borderSprites.forEach((sprite, hexId) => {
            if (!visibleHexIds.has(hexId)) {
                sprite.visible = false;
            }
        });
    }

    /**
     * Updates the selection highlight
     */
    updateSelection(selectedHexId: string | null, hexTiles: HexTile[]): void {
        if (!this.textures) return;

        // Remove existing highlight
        if (this.selectedHexSprite) {
            this.highlightContainer.removeChild(this.selectedHexSprite);
            this.selectedHexSprite.destroy();
            this.selectedHexSprite = null;
        }

        // Add new highlight if a hex is selected
        if (selectedHexId) {
            const selectedHex = hexTiles.find(h => h.id === selectedHexId);
            if (selectedHex) {
                const pixel = axialToPixelOriented(selectedHex.coordinates.q, selectedHex.coordinates.r, this.tileSize, this.hexOrientation);
                const highlightSprite = new PIXI.Sprite(this.textures.highlight);
                highlightSprite.anchor.set(0.5);
                highlightSprite.x = pixel.x;
                highlightSprite.y = pixel.y;
                this.highlightContainer.addChild(highlightSprite);
                this.selectedHexSprite = highlightSprite;
            }
        }
    }

    /**
     * Sets border container visibility
     */
    setBorderVisibility(visible: boolean): void {
        this.borderContainer.visible = visible;
    }

    /**
     * Gets rendering statistics
     */
    getStats(): { fillSprites: number, borderSprites: number } {
        return {
            fillSprites: this.fillSprites.size,
            borderSprites: this.borderSprites.size
        };
    }

    /**
     * Cleans up all sprites and resources
     */
    destroy(): void {
        this.fillSprites.forEach(sprite => sprite.destroy());
        this.borderSprites.forEach(sprite => sprite.destroy());
        if (this.selectedHexSprite) {
            this.selectedHexSprite.destroy();
        }

        this.fillSprites.clear();
        this.borderSprites.clear();
        this.selectedHexSprite = null;
    }

    /**
     * Test method to check alpha behavior
     */
    private testAlpha(sprite: PIXI.Sprite, expectedAlpha: number, hexId: string): void {
        // Set alpha and immediately check it
        sprite.alpha = expectedAlpha;
        const actualAlpha = sprite.alpha;

        if (Math.abs(actualAlpha - expectedAlpha) > 0.01) {
            console.warn('[HexRenderer] Alpha mismatch for', hexId, 'expected:', expectedAlpha, 'actual:', actualAlpha);
        }

        // Also check parent container alpha
        if (sprite.parent && sprite.parent.alpha !== 1) {
            console.warn('[HexRenderer] Parent container alpha is not 1:', sprite.parent.alpha, 'for hex:', hexId);
        }
    }
}
